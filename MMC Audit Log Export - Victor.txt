# ==============================
# Configurable parameters
# ==============================
$SqlServer  = "usdf11v0842"
#$SqlServer  = "localhost"
$Database   = "ACVSCore"
$OutputFile = "D:\SIEM\Logs\auditlog-output.json"

function Get-ApplicationServerIP {

    # SQL Query
    $Query = "select MachineName from ACVSCore.dbo.ApplicationServer"

    # Connection String (Windows Integrated Auth)
    $ConnectionString = "Server=$SQLServer;Database=ACVSCore;Integrated Security=True;"

    $MachineNames = @()

    try {
        # Create SQL Connection
        $Connection = New-Object System.Data.SqlClient.SqlConnection
        $Connection.ConnectionString = $ConnectionString
        $Connection.Open()

        # Create SQL Command
        $Command = $Connection.CreateCommand()
        $Command.CommandText = $Query

        # Execute Reader
        $Reader = $Command.ExecuteReader()

        while ($Reader.Read()) {
            $MachineNames += $Reader["MachineName"]
        }

        $Reader.Close()
        $Connection.Close()
    }
    catch {
        Write-Error "SQL Query Failed on [$SQLServer]: $_"
        return
    }

    # Resolve DNS for each machine
    $Results = foreach ($Machine in $MachineNames) {

        if ([string]::IsNullOrWhiteSpace($Machine)) {
            continue
        }

        try {
            $IP = (Resolve-DnsName -Name $Machine -ErrorAction Stop |
                   Where-Object { $_.Type -eq "A" } |
                   Select-Object -First 1 -ExpandProperty IPAddress)

            [PSCustomObject]@{
                MachineName = $Machine
                IPAddress   = $IP
                Status      = "Resolved"
            }
        }
        catch {
            [PSCustomObject]@{
                MachineName = $Machine
                IPAddress   = $null
                Status      = "DNS Lookup Failed"
            }
        }
    }

    return $Results
}

# ==============================
# SQL query
# ==============================
$query = @'
select
'Victor' as SystemName,
Dateadd(mi, ServerLocaleOffset * -1, ServerUTC) as LocalEventTime, 
serverutc as ServerUTC,
OperatorName,
--PrimaryObjectType,
--PrimaryObjectName,
--SecondaryObjectType,
--SecondaryObjectName,
--EditOperation,
TransactionSequence,
Case
When EditOperation = 1 Then 'Create Object'
When EditOperation = 2 Then 'Delete Object'
When EditOperation = 3 Then 'Edit Object'
When EditOperation = 4 Then 'Add Object Property'
When EditOperation = 5 Then 'Remove Object Property'
END
As EventName,

Case
When EditOperation = 1 Then CONCAT(LEFT(PrimaryObjectType, CHARINDEX('.', PrimaryObjectType) - 1),' ', REVERSE(LEFT(REVERSE(PrimaryObjectType), CHARINDEX('.', REVERSE(PrimaryObjectType)) - 1)),' "', PrimaryObjectName,'" was created')
When EditOperation = 2 Then CONCAT(LEFT(PrimaryObjectType, CHARINDEX('.', PrimaryObjectType) - 1),' ', REVERSE(LEFT(REVERSE(PrimaryObjectType), CHARINDEX('.', REVERSE(PrimaryObjectType)) - 1)),' "', PrimaryObjectName,'" was deleted')
When EditOperation = 3 Then CONCAT(LEFT(PrimaryObjectType, CHARINDEX('.', PrimaryObjectType) - 1),' ', REVERSE(LEFT(REVERSE(PrimaryObjectType), CHARINDEX('.', REVERSE(PrimaryObjectType)) - 1)),' "', PrimaryObjectName,'" was modified')
When EditOperation = 4 Then CONCAT(LEFT(SecondaryObjectType, CHARINDEX('.', SecondaryObjectType) - 1),' ', REVERSE(LEFT(REVERSE(SecondaryObjectType), CHARINDEX('.', REVERSE(SecondaryObjectType)) - 1)),' "', SecondaryObjectName,'" was added to "',PrimaryObjectName,'"')
When EditOperation = 5 Then CONCAT(LEFT(SecondaryObjectType, CHARINDEX('.', SecondaryObjectType) - 1),' ', REVERSE(LEFT(REVERSE(SecondaryObjectType), CHARINDEX('.', REVERSE(SecondaryObjectType)) - 1)),' "', SecondaryObjectName,'" was removed from "',PrimaryObjectName, '"')

END
As OperationMessage
from ACVSAudit.dbo.AuditLog
Where Dateadd(mi, ServerLocaleOffset * -1, ServerUTC) > Dateadd(hh,-12, GetDate())
And PrimaryObjectType not like 'SoftwareHouse.CrossFire.Common.DataServiceLayer%' and PrimaryObjectType != 'SoftwareHouse.CrossFire.Common.Objects.AccessWorkstation'
--order by serverutc desc, TransactionSequence

ORDER BY ServerUTC DESC, TransactionSequence;
'@

# ==============================
# Run query and fetch results
# ==============================
$connectionString = "Server=$SqlServer;Database=$Database;Integrated Security=True;TrustServerCertificate=True;"

$connection = New-Object System.Data.SqlClient.SqlConnection $connectionString
$command    = $connection.CreateCommand()
$command.CommandText = $query

$table = New-Object System.Data.DataTable

try {
    $connection.Open()
    $adapter = New-Object System.Data.SqlClient.SqlDataAdapter $command
    [void]$adapter.Fill($table)
}
finally {
    if ($connection.State -ne 'Closed') {
        $connection.Close()
    }
}

# ==============================
# Build JSON objects
# ==============================
$ServerIP = Get-ApplicationServerIP
$events = @()

# 1) Heartbeat row (always first)
$heartbeat = [pscustomobject]@{
    ActingAsUser          = ""
    ActorName             = ""
    ApplicationCode       = "Victor"
    ApplicationComponent  = ""
    ApplicationInstance   = ""
    AuthenticationChannel = ""
    ClientIPAddress       = $ServerIP.IPAddress
    Context               = ""
    CorrelationID         = ""
    EventID               = ""
    EventName             = "heartbeat"
    EventType             = ""
    IdentityProvider      = ""
    Location              = ""
    Msg                   = "heartbeat"
    SessionID             = ""
    Severity              = "Info"
    Timestamp             = (Get-Date).ToString("o")  # ISO 8601
    TrackingNumber        = ""
}

$events += $heartbeat

# 2) Map each SQL row -> desired JSON shape
foreach ($row in $table.Rows) {
    $localTime = $null
    if ($row.LocalEventTime -ne $null -and $row.LocalEventTime -ne [DBNull]::Value) {
        $localTime = ([datetime]$row.LocalEventTime).ToString("o")
    }

    $event = [pscustomobject]@{
        ActingAsUser          = ""                               
        ActorName             = "$($row.OperatorName)"           
        ApplicationCode       = "$($row.SystemName)"
        ApplicationComponent  = ""
        ApplicationInstance   = ""
        AuthenticationChannel = ""
        ClientIPAddress       = $ServerIP.IPAddress
        Context               = ""
        CorrelationID         = ""
        EventID               = ""
        EventName             = "$($row.EventName)"            
        EventType             = ""
        IdentityProvider      = ""
        Location              = ""
        Msg                   = "$($row.OperationMessage)"      
        SessionID             = ""
        Severity              = ""                               
        Timestamp             = $localTime
        TrackingNumber        = ""
    }

    $events += $event
}

# ==============================
# Write to JSON file
# ==============================
$events | ConvertTo-Json -Depth 5 | Set-Content -Path $OutputFile -Encoding UTF8

$ArchivePath = $OutputFile -replace '\.(\w+)$', "_$(Get-Date -Format 'ddMMyyyy-HHmm').`$1"

$events | ConvertTo-Json -Depth 5 | Set-Content -Path $ArchivePath -Encoding UTF8

Write-Host "Wrote $($events.Count) records to $OutputFile"

# ==============================
# Cleanup files older than 30 days
# ==============================

$CleanupPath = Split-Path $OutputFile -Parent
$CleanupPath = $CleanupPath + '\*.json'

try {
Get-ChildItem $CleanupPath -ErrorAction Stop | where-object {$_.LastWriteTime -lt (get-date).AddDays(-30)} | Remove-Item -ErrorAction Stop
} catch {
Write-Host "Cleanup of $LogFileDestination log files failed $_"
}
